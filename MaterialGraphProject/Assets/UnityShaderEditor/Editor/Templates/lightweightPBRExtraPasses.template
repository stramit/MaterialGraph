Pass
{
    Tags{"LightMode" = "ShadowCaster"}

    ZWrite On ZTest LEqual

    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma target 2.0

    //--------------------------------------
    // GPU Instancing
    #pragma multi_compile_instancing

    #pragma vertex ShadowPassVertex
    #pragma fragment ShadowPassFragment

    #include "LWRP/ShaderLibrary/Core.hlsl"

${Graph}

    // x: global clip space bias, y: normal world space bias
    float4 _ShadowBias;
    float3 _LightDirection;

    float4 ShadowPassVertex(GraphVertexInput v) : SV_POSITION
    {
		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

${VertexDescriptionInputs}

	    VertexDescription vd = PopulateVertexData(vdi);
        v.vertex.xyz = vd.Position;

        float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
        float3 normalWS = TransformObjectToWorldDir(v.normal);

        float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
        float scale = invNdotL * _ShadowBias.y;

        // normal bias is negative since we want to apply an inset normal offset
        positionWS = normalWS * scale.xxx + positionWS;
        float4 clipPos = TransformWorldToHClip(positionWS);

        // _ShadowBias.x sign depens on if platform has reversed z buffer
        clipPos.z += _ShadowBias.x;

    #if defined(UNITY_REVERSED_Z)
        clipPos.z = min(clipPos.z, 1.0);
    #else
        clipPos.z = max(clipPos.z, 0.0);
    #endif
        return clipPos;
    }

    half4 ShadowPassFragment() : SV_TARGET
    {
        return 0;
    }

    ENDHLSL
}

Pass
{
    Tags{"LightMode" = "DepthOnly"}

    ZWrite On
    ColorMask 0

    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma target 2.0
    #pragma vertex vert
    #pragma fragment frag

    #include "LWRP/ShaderLibrary/Core.hlsl"

${Graph}

    float4 vert(GraphVertexInput v) : SV_POSITION
    {
		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

${VertexDescriptionInputs}

	    VertexDescription vd = PopulateVertexData(vdi);
        v.vertex.xyz = vd.Position;
        return TransformObjectToHClip(v.vertex.xyz);
    }

    half4 frag() : SV_TARGET
    {
        return 0;
    }
    ENDHLSL
}

// This pass it not used during regular rendering, only for lightmap baking.
Pass
{
    Tags{"LightMode" = "Meta"}

    Cull Off

    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles

    #pragma vertex LightweightVertexMeta
    #pragma fragment LightweightFragmentMeta

    #pragma shader_feature _SPECULAR_SETUP
    #pragma shader_feature _EMISSION
    #pragma shader_feature _METALLICSPECGLOSSMAP
    #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A
    #pragma shader_feature EDITOR_VISUALIZATION

    #pragma shader_feature _SPECGLOSSMAP

    #include "LWRP/ShaderLibrary/LightweightPassMeta.hlsl"
    ENDHLSL
}